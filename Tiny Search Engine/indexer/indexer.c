/** 
 * indexer.c
 * Author: Louis Weisdorf
 * CS50 Spring 2023, Lab 5
 * Date: 04/29/2023
 * Description: This program provides the second component of the 
 *      tiny search engine (TSE) project, creating an inverted index 
 *      of words,documents from documents created by the crawler.
 */
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include "../libcs50/mem.h"
#include "../libcs50/webpage.h"
#include "../libcs50/file.h"
#include "../common/pagedir.h"
#include "../common/index.h"
#include "../common/word.h"

// Declaring functions
void indexBuild(char* pageDirectory, char* indexFilename);
void indexPage(index_t* index, webpage_t* webpage, int docID);

// Main function parses arguments and calls other functions
int main(const int argc, char *argv[])
{
    // If the number of arguments given is invalid
    if (argc != 3) {
        // Printing error message and exiting with non-zero
        fprintf(stderr, "\nError: Invalid number of arguments passed.\n");
        exit(1);
    }

    // Saving arguments in variables
    char* pageDirectory = argv[1];
    char* indexFilename = argv[2];

    // If the pageDirectory is not produced by the crawler (is invalid)
    if (!pagedir_validate(pageDirectory)) {
        // Printing error message and exiting with non-zero
        fprintf(stderr, "\nError: Provided pageDirectory is invalid.\n");
        exit(2);
    }

    // If the indexFilename is not valid for writing
    if (!index_filecheck(indexFilename)) {
        // Printing error message and exiting with non-zero
        fprintf(stderr, "\nError: Provided indexFilename is invalid.\n");
        exit(3);
    }

    // If arguments pass checks
    else {
        // Calling indexBuild with pageDirectory
        indexBuild(pageDirectory, indexFilename);
    }
    
    // Exiting with code 0 upon successful termination
    exit(0);
}

/******************** indexBuild *******************************/
/* Function takes a (crawler-produced) pageDirectory as parameter,
*  along with the indexFilename, building an in-memory index 
*  from webpage files it finds in the 
*  pageDirectory.
*/
void indexBuild(char* pageDirectory, char* indexFilename)
{
    // Creating a new index object
    index_t* index = index_new(800);
    
    // Creating a variable to track docID (starting at 1)
    int docID = 1;

    // Looping over crawler files in pageDirectory
    while (true) {
        // Creating variable to store pathName (as generated by index_pathname)
        char* pathName = index_pathname(pageDirectory, docID);

        // Opening file with generated pathName
        FILE* file = fopen(pathName, "r");

        // Freeing the memory allocated for pathName
        mem_free(pathName);

        // Checking if opening the file was successful (if the file exists)
        if (file == NULL) {
            // Breaking out of the loop
            break;
        }

        // Creating a new webpage object to pass to indexPage
        webpage_t* webpage = pagedir_load(file);

        // Calling indexPage with retrieved information
        indexPage(index, webpage, docID);

        // Closing the file
        fclose(file);

        // Incrementing the docID
        docID++;
    } 

    // Calling index_write to write index into indexFilename
    index_write(index, indexFilename);
}

/******************** index_page *******************************/
/* Function takes an index, webpage, and docID as parameters,
*  scanning the webpage document to add its word to the index.
*/
void indexPage(index_t* index, webpage_t* webpage, int docID)
{
    // Setting up variables to handle reading words from webpage
    int pos = 0;
    char* word;

    // Looping over words in the webpage
    while ((word = webpage_getNextWord(webpage, &pos)) != NULL) {
        // Checking if the word is too short
        if (word_check(word)) {
            // Normalize the word
            word = word_normalize(word);

            /* Calling index_insert function on the word.
            This will either lead to insertion of the word in the index
            or incrementation of the count in the given docID. */
            index_insert(index, word, docID);
        }

        // Freeing the memory allocated for the word
        mem_free(word);
    }
    
    // Deleting the webpage object created in indexBuild
    webpage_delete(webpage);
}
